import java.util.TreeMap;	// implementation of Map and SortedMap interfaces that maintains ascending order


import java.util.concurrent.TimeUnit;
import java.util.ArrayList;
import java.util.Map;
import java.util.Map.Entry;
import javax.swing.JFrame;

public class NMmethod {
	public static double Himmelblau(double x, double y) {
		return Math.pow(Math.pow(x, 2) + y - 11, 2) + Math.pow(x + Math.pow(y, 2) - 7, 2);
	}
	
	public static double Himmelblau(Point p) {
		int n = p.getNumOfValues();
		if (n != 2) {
			return -1.0;
		}
		else {
			return Math.pow(Math.pow(p.getValue(0), 2) + p.getValue(1) - 11, 2) + Math.pow(p.getValue(0) + Math.pow(p.getValue(1), 2) - 7, 2);
		}
	}

	/**
	 * Order the test points of the simplex according to the values of the function to be optimized.
	 * 
	 * @param sim the simplex
	 */
	public static void order(Simplex sim) {
		TreeMap<Double, Point> testPointsFuncValues = new TreeMap<Double, Point>();
		int numOfTestPoints = sim.getNumOfTestPoints();
		for (int testPointIndex = 0; testPointIndex < numOfTestPoints; testPointIndex++) {
			Point testPoint = sim.getPoint(testPointIndex);
			Double testPointFuncValue = Himmelblau(testPoint);
			testPointsFuncValues.put(testPointFuncValue, testPoint);
		}
		
		int i = 0;
		for (Entry<Double, Point> entry : testPointsFuncValues.entrySet()) {
			Point testPoint = entry.getValue();
			Double testPointFuncValue = entry.getKey();
			System.out.println(i + "," + testPointFuncValue);
			sim.setPoint(i, testPoint);
			i++;
		}
	}
	
	/**
	 * Calculates the centroid of all points of the simplex except of the x_{n+1}.
	 * 
	 * @param sim the simplex
	 * @return the centroid
	 */
	public static Point calcCentroid(Simplex sim) {
		int numOfTestPoints = sim.getNumOfTestPoints();
		int dimension = numOfTestPoints - 1;
		
		// the centroid point
		Point centroid  = new Point();
		centroid.setDimension(dimension);		
		for (int i = 0; i < dimension; i++) {
			double val = 0.0;
			for (int testPointIndex = 0; testPointIndex < numOfTestPoints; testPointIndex++) {
				val += sim.getPoint(testPointIndex).getValue(i);
			}
			val /= numOfTestPoints;
			centroid.addVal(val);
		}
		return centroid;
	}
	
	/**
	 * Subtracts the values of two points, thus generating a new point. (it could be an operator overloading function in C++).
	 * 
	 * @param p1 the first point
	 * @param p2 the second point
	 * @return the new point generated by the subtraction of the two points
	 */
	public static Point subtract(Point p1, Point p2) {
		int n1 = p1.getNumOfValues();
		int n2 = p2.getNumOfValues();
		Point diff = new Point();
		if (n1 == n2) {
			int dimension = n1;
			diff.setDimension(dimension);
			for (int valueIndex = 0; valueIndex < dimension; valueIndex++) {
				double val = p1.getValue(valueIndex) - p2.getValue(valueIndex);
				diff.addVal(val);
			}
		}
		return diff;
	}
	
	/**
	 * Multiplies the values of a point with a constant, thus generating a new point. (it could be an operator overloading function in C++).
	 * 
	 * @param p the point
	 * @param c the constant
	 * @return the new point generated by the multiplication of a point with a constant
	 */
	public static Point multiplyPointByConstant(Point p, double c) {
		int dimension = p.getNumOfValues();
		Point product = new Point();
		product.setDimension(dimension);
		for (int valueIndex = 0; valueIndex < dimension; valueIndex++) {
			double val = c * p.getValue(valueIndex);
			product.addVal(val);
		}
		return product;
	}
	
	/**
	 * Adds the values of two points, thus generating a new point. (it could be an operator overloading function in C++).
	 * 
	 * @param p1 the first point
	 * @param p2 the second point
	 * @return the new point generated by the addition of the two points
	 */
	public static Point add(Point p1, Point p2) {
		int n1 = p1.getNumOfValues();
		int n2 = p2.getNumOfValues();
		Point sum = new Point();
		if (n1 == n2) {
			int dimension = n1;
			sum.setDimension(dimension);
			for (int valueIndex = 0; valueIndex < dimension; valueIndex++) {
				double val = p1.getValue(valueIndex) + p2.getValue(valueIndex);
				sum.addVal(val);
			}
		}
		return sum;
	}
	
	/**
	 * Computes reflected point.
	 * 
	 * @param centroid the centroid of the simplex
	 * @param lastPoint the last point of the simplex
	 * @return
	 */
	public static Point reflection(Point centroid, Point lastPoint) {
		double alpha = 1.0;
		Point reflectedPoint = add(centroid, multiplyPointByConstant(subtract(centroid, lastPoint), alpha));
		return reflectedPoint;
	}
	
	public static double mean(ArrayList<Double> vals) {
		double m = 0.0;
		for (int i = 0; i < vals.size(); i++) {
			m += vals.get(i);
		}
		m /= vals.size();
		return m;
	}
	
	public static double std(ArrayList<Double> vals) {
		double s = 0.0;
		double m = mean(vals);
		for (int i = 0; i < vals.size(); i++) {
			s += Math.pow(vals.get(i) - m, 2);
		}
		s /= (double)(vals.size() - 1);
		s = Math.sqrt(s);
		return s;
	}
	

	

	

	

	

	
	public static Point expansion(Point centroid, Point reflectedPoint) {
		double gamma = 2.0;
		Point expandedPoint = subtract(reflectedPoint, centroid);
		expandedPoint = multiplyConstantByPoint(gamma, expandedPoint);
		expandedPoint = add(centroid, expandedPoint);
		return expandedPoint;
	}
	
	public static Point contraction(Point centroid, Point lastPoint) {
		double rho = 0.5;
		Point contractedPoint = subtract(lastPoint, centroid);
		contractedPoint = multiplyConstantByPoint(rho, contractedPoint);
		contractedPoint = add(centroid, contractedPoint);
		return contractedPoint;
	}
	
	public static void shrink(Simplex sim, Point bestPoint, int bestPointId) {
		double sigma = 0.5; 
		int numOfPoints = sim.getNumOfPoints();
		for (int i = 0; i < numOfPoints; i++) {
			if (i != bestPointId) {
				Point newPoint = subtract(sim.getPoint(i), bestPoint);
				newPoint = multiplyConstantByPoint(sigma, newPoint);
				newPoint = add(newPoint, bestPoint);
				sim.setPoint(i, newPoint);
			}
		}
	}
	
	public static double computeSimplexStd(Simplex sim) {
		// Compute f values for the points of the Simplex
		ArrayList<Double> fvals = new ArrayList<Double>();
		int numOfPoints = sim.getNumOfPoints();
		for (int i = 0; i < numOfPoints; i++) {
			double fval = Himmelblau(sim.getPoint(i));
			fvals.add(fval);
		}
		
		// Compute standard deviation of the f values
		double s = std(fvals);
		return s;
	}
	
	public static boolean isTerminated(Simplex sim, double threshold){
		boolean terminated = false;
		double simplexStd = computeSimplexStd(sim);
		if (simplexStd < threshold) {
			terminated = true;
		}
		return terminated;		
	}
	
	public static void main(String[] args) {
		// Visualize
		JFrame frame = new JFrame("Running...");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setSize(500, 500);
		frame.setLocationRelativeTo(null);
		frame.setVisible(true);
		
		// create a new simplex
		int numOfTestPoints = 3;
		double rangeMin = 1.0;
		double rangeMax = 5.0;
		Simplex sim = new Simplex(numOfTestPoints, rangeMin, rangeMax);
		
		int delayTime = 1;
		double threshold = 10.0;
		int iterationIndex = 1;
		double simplexStd = 0.0;
		double minFval = 0.0;
		boolean terminated = isTerminated(sim, threshold);
		
		// iteration
		while (!terminated) {
			Order(sim);
			
			simplexStd = computeSimplexStd(sim);
			minFval = Himmelblau(sim.getPoint(numOfTestPoints - 1));
			System.out.printf("Iteration: %d", iterationIndex);
			System.out.printf(", Simplex standard deviation: %.2f ", simplexStd);
			System.out.printf(", Minimum value of function: %.2f ", minFval);
			System.out.println();
			iterationIndex += 1;
			
			// Calculate centroid
			Point centroid = calcCentroid(sim);
			
			// Calculate reflected point
			Point reflectedPoint = reflection(centroid, sim.getPoint(numOfTestPoints - 1));
			
			// Check reflected point
			double fBest = Himmelblau(sim.getPoint(0));
			double fReflectedPoint = Himmelblau(reflectedPoint);
			double fSecondWorst = Himmelblau(sim.getPoint(numOfPoints - 2));
			
			if (fReflectedPoint >= fBest && fReflectedPoint <= fSecondWorst) {
				sim.setPoint(numOfPoints - 1, reflectedPoint);
				terminated = isTerminated(sim, threshold);
			}
			else if (fReflectedPoint < fBest) {
				Point expandedPoint = expansion(centroid, reflectedPoint);
				double fExpandedPoint = Himmelblau(expandedPoint);
				if (fExpandedPoint < fReflectedPoint) {
					sim.setPoint(numOfPoints - 1, expandedPoint);
					terminated = isTerminated(sim, threshold);
				}
				else {
					sim.setPoint(numOfPoints - 1, reflectedPoint);
					terminated = isTerminated(sim, threshold);
				}
			}
			else {
				Point contractedPoint = contraction(centroid, sim.getPoint(numOfPoints - 1));
				double fContractedPoint = Himmelblau(contractedPoint);
				double fWorstPoint = Himmelblau(sim.getPoint(numOfPoints - 1));
				if (fContractedPoint < fWorstPoint) {
					sim.setPoint(numOfPoints - 1, contractedPoint);
					terminated = isTerminated(sim, threshold);
				}
				else {
					shrink(sim,  sim.getPoint(numOfPoints - 1), numOfPoints - 1);
				}
			}
			
			PointDrawer pointsDrawer = new PointDrawer(sim.getPoints());
			frame.add(pointsDrawer);
			frame.repaint();
			frame.revalidate();
			try {
				TimeUnit.SECONDS.sleep(delayTime);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		System.out.printf("The algorithm converged in %d iterations with minimum simplex stardard deviation %.2f and minimum value of function %.2f.", iterationIndex - 1, simplexStd, minFval);
	}
}